{"ast":null,"code":"import { interpolate } from \"react-native-reanimated\";\nimport parseSVG from \"parse-svg-path\";\nimport absSVG from \"abs-svg-path\";\nimport normalizeSVG from \"normalize-svg-path\";\nimport { cubicBezierYForX } from \"./Math\";\nexport var SVGCommand;\n\n(function (SVGCommand) {\n  SVGCommand[SVGCommand[\"MOVE\"] = 0] = \"MOVE\";\n  SVGCommand[SVGCommand[\"CURVE\"] = 1] = \"CURVE\";\n  SVGCommand[SVGCommand[\"CLOSE\"] = 2] = \"CLOSE\";\n})(SVGCommand || (SVGCommand = {}));\n\nexport var exhaustiveCheck = function exhaustiveCheck(command) {\n  \"worklet\";\n\n  throw new TypeError(\"Unknown SVG Command: \" + command);\n};\n\nvar serializeMove = function serializeMove(c) {\n  \"worklet\";\n\n  return \"M\" + c.x + \",\" + c.y + \" \";\n};\n\nvar serializeClose = function serializeClose() {\n  \"worklet\";\n\n  return \"Z\";\n};\n\nvar serializeCurve = function serializeCurve(c) {\n  \"worklet\";\n\n  return \"C\" + c.c1.x + \",\" + c.c1.y + \" \" + c.c2.x + \",\" + c.c2.y + \" \" + c.to.x + \",\" + c.to.y + \" \";\n};\n\nvar isMove = function isMove(command) {\n  \"worklet\";\n\n  return command.type === SVGCommand.MOVE;\n};\n\nvar isCurve = function isCurve(command) {\n  \"worklet\";\n\n  return command.type === SVGCommand.CURVE;\n};\n\nvar isClose = function isClose(command) {\n  \"worklet\";\n\n  return command.type === SVGCommand.CLOSE;\n};\n\nexport var serialize = function serialize(path) {\n  \"worklet\";\n\n  return path.map(function (segment) {\n    if (isMove(segment)) {\n      return serializeMove(segment);\n    }\n\n    if (isCurve(segment)) {\n      return serializeCurve(segment);\n    }\n\n    if (isClose(segment)) {\n      return serializeClose();\n    }\n\n    return exhaustiveCheck(segment);\n  }).reduce(function (acc, c) {\n    return acc + c;\n  });\n};\nexport var parse = function parse(d) {\n  var segments = normalizeSVG(absSVG(parseSVG(d)));\n  return segments.map(function (segment, index) {\n    if (segment[0] === \"M\") {\n      return move(segment[1], segment[2]);\n    } else if (segment[0] === \"Z\") {\n      return close();\n    } else {\n      var _ref, _ref2;\n\n      var prev = segments[index - 1];\n      var r = curve({\n        c1: {\n          x: segment[1],\n          y: segment[2]\n        },\n        c2: {\n          x: segment[3],\n          y: segment[4]\n        },\n        to: {\n          x: segment[5],\n          y: segment[6]\n        },\n        from: {\n          x: (_ref = prev[0] === \"M\" ? prev[1] : prev[5]) != null ? _ref : 0,\n          y: (_ref2 = prev[0] === \"M\" ? prev[2] : prev[6]) != null ? _ref2 : 0\n        }\n      });\n      return r;\n    }\n  });\n};\nexport var interpolatePath = function interpolatePath(value, inputRange, outputRange) {\n  \"worklet\";\n\n  var path = outputRange[0].map(function (segment, index) {\n    if (isMove(segment)) {\n      var points = outputRange.map(function (p) {\n        var s = p[index];\n\n        if (isMove(s)) {\n          return {\n            x: s.x,\n            y: s.y\n          };\n        }\n\n        throw new Error(\"Paths to interpolate are not symetrical\");\n      });\n      return {\n        type: SVGCommand.MOVE,\n        x: interpolate(value, inputRange, points.map(function (p) {\n          return p.x;\n        })),\n        y: interpolate(value, inputRange, points.map(function (p) {\n          return p.y;\n        }))\n      };\n    }\n\n    if (isCurve(segment)) {\n      var curves = outputRange.map(function (p) {\n        var s = p[index];\n\n        if (isCurve(s)) {\n          return {\n            to: s.to,\n            c1: s.c1,\n            c2: s.c2\n          };\n        }\n\n        throw new Error(\"Paths to interpolate are not symetrical\");\n      });\n      return {\n        type: SVGCommand.CURVE,\n        to: {\n          x: interpolate(value, inputRange, curves.map(function (c) {\n            return c.to.x;\n          })),\n          y: interpolate(value, inputRange, curves.map(function (c) {\n            return c.to.y;\n          }))\n        },\n        c1: {\n          x: interpolate(value, inputRange, curves.map(function (c) {\n            return c.c1.x;\n          })),\n          y: interpolate(value, inputRange, curves.map(function (c) {\n            return c.c1.y;\n          }))\n        },\n        c2: {\n          x: interpolate(value, inputRange, curves.map(function (c) {\n            return c.c2.x;\n          })),\n          y: interpolate(value, inputRange, curves.map(function (c) {\n            return c.c2.y;\n          }))\n        }\n      };\n    }\n\n    return segment;\n  });\n  return serialize(path);\n};\nexport var mixPath = function mixPath(value, p1, p2) {\n  \"worklet\";\n\n  return interpolatePath(value, [0, 1], [p1, p2]);\n};\nexport var move = function move(x, y) {\n  \"worklet\";\n\n  return {\n    type: SVGCommand.MOVE,\n    x: x,\n    y: y\n  };\n};\nexport var curve = function curve(c) {\n  \"worklet\";\n\n  return {\n    type: SVGCommand.CURVE,\n    c1: c.c1,\n    c2: c.c2,\n    to: c.to,\n    from: c.from\n  };\n};\nexport var close = function close() {\n  \"worklet\";\n\n  return {\n    type: SVGCommand.CLOSE\n  };\n};\nexport var getYForX = function getYForX(path, x) {\n  \"worklet\";\n\n  var p = path.filter(function (c) {\n    if (isCurve(c)) {\n      if (c.from.x > c.to.x) {\n        return x >= c.to.x && x <= c.from.x;\n      }\n\n      return x >= c.from.x && x <= c.to.x;\n    }\n\n    return false;\n  });\n\n  if (isCurve(p[0])) {\n    return cubicBezierYForX(x, p[0].from, p[0].c1, p[0].c2, p[0].to);\n  }\n\n  return 0;\n};","map":{"version":3,"sources":["Paths.ts"],"names":["SVGCommand","exhaustiveCheck","serializeMove","c","serializeClose","serializeCurve","isMove","command","isCurve","isClose","serialize","path","acc","parse","segments","normalizeSVG","absSVG","parseSVG","segment","move","close","prev","index","r","curve","c1","x","y","c2","to","from","interpolatePath","outputRange","points","s","p","type","interpolate","curves","mixPath","getYForX","cubicBezierYForX"],"mappings":"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","sourcesContent":["import { interpolate } from \"react-native-reanimated\";\nimport parseSVG from \"parse-svg-path\";\nimport absSVG from \"abs-svg-path\";\nimport normalizeSVG from \"normalize-svg-path\";\n\nimport { Vector } from \"./Vectors\";\nimport { cubicBezierYForX } from \"./Math\";\n\ntype SVGCloseCommand = [\"Z\"];\ntype SVGMoveCommand = [\"M\", number, number];\ntype SVGCurveCommand = [\"C\", number, number, number, number, number, number];\ntype SVGNormalizedCommands = [\n  SVGMoveCommand | SVGCurveCommand | SVGCloseCommand\n];\n\nexport enum SVGCommand {\n  MOVE,\n  CURVE,\n  CLOSE,\n}\n\ninterface Move extends Vector {\n  type: SVGCommand.MOVE;\n}\n\ninterface Curve {\n  type: SVGCommand.CURVE;\n  from: Vector;\n  to: Vector;\n  c1: Vector;\n  c2: Vector;\n}\n\ninterface Close {\n  type: SVGCommand.CLOSE;\n}\n\nexport type Segment = Close | Curve | Move;\nexport type Path = Segment[];\n\nexport const exhaustiveCheck = (command: never): never => {\n  \"worklet\";\n  throw new TypeError(`Unknown SVG Command: ${command}`);\n};\n\nconst serializeMove = (c: Move) => {\n  \"worklet\";\n  return `M${c.x},${c.y} `;\n};\n\nconst serializeClose = () => {\n  \"worklet\";\n  return \"Z\";\n};\n\nconst serializeCurve = (c: Curve) => {\n  \"worklet\";\n  return `C${c.c1.x},${c.c1.y} ${c.c2.x},${c.c2.y} ${c.to.x},${c.to.y} `;\n};\n\nconst isMove = (command: Segment): command is Move => {\n  \"worklet\";\n  return command.type === SVGCommand.MOVE;\n};\n\nconst isCurve = (command: Segment): command is Curve => {\n  \"worklet\";\n  return command.type === SVGCommand.CURVE;\n};\n\nconst isClose = (command: Segment): command is Close => {\n  \"worklet\";\n  return command.type === SVGCommand.CLOSE;\n};\n\nexport const serialize = (path: Path) => {\n  \"worklet\";\n  return path\n    .map((segment) => {\n      if (isMove(segment)) {\n        return serializeMove(segment);\n      }\n      if (isCurve(segment)) {\n        return serializeCurve(segment);\n      }\n      if (isClose(segment)) {\n        return serializeClose();\n      }\n      return exhaustiveCheck(segment);\n    })\n    .reduce((acc, c) => acc + c);\n};\n\nexport const parse = (d: string): Path => {\n  const segments: SVGNormalizedCommands = normalizeSVG(absSVG(parseSVG(d)));\n  return segments.map((segment, index) => {\n    if (segment[0] === \"M\") {\n      return move(segment[1], segment[2]);\n    } else if (segment[0] === \"Z\") {\n      return close();\n    } else {\n      const prev = segments[index - 1];\n      const r = curve({\n        c1: {\n          x: segment[1],\n          y: segment[2],\n        },\n        c2: {\n          x: segment[3],\n          y: segment[4],\n        },\n        to: {\n          x: segment[5],\n          y: segment[6],\n        },\n        from: {\n          x: (prev[0] === \"M\" ? prev[1] : prev[5]) ?? 0,\n          y: (prev[0] === \"M\" ? prev[2] : prev[6]) ?? 0,\n        },\n      });\n      return r;\n    }\n  });\n};\n\nexport const interpolatePath = (\n  value: number,\n  inputRange: number[],\n  outputRange: Path[]\n) => {\n  \"worklet\";\n  const path = outputRange[0].map((segment, index) => {\n    if (isMove(segment)) {\n      const points = outputRange.map((p) => {\n        const s = p[index];\n        if (isMove(s)) {\n          return {\n            x: s.x,\n            y: s.y,\n          };\n        }\n        throw new Error(\"Paths to interpolate are not symetrical\");\n      });\n      return {\n        type: SVGCommand.MOVE,\n        x: interpolate(\n          value,\n          inputRange,\n          points.map((p) => p.x)\n        ),\n        y: interpolate(\n          value,\n          inputRange,\n          points.map((p) => p.y)\n        ),\n      } as Move;\n    }\n    if (isCurve(segment)) {\n      const curves = outputRange.map((p) => {\n        const s = p[index];\n        if (isCurve(s)) {\n          return {\n            to: s.to,\n            c1: s.c1,\n            c2: s.c2,\n          };\n        }\n        throw new Error(\"Paths to interpolate are not symetrical\");\n      });\n      return {\n        type: SVGCommand.CURVE,\n        to: {\n          x: interpolate(\n            value,\n            inputRange,\n            curves.map((c) => c.to.x)\n          ),\n          y: interpolate(\n            value,\n            inputRange,\n            curves.map((c) => c.to.y)\n          ),\n        },\n        c1: {\n          x: interpolate(\n            value,\n            inputRange,\n            curves.map((c) => c.c1.x)\n          ),\n          y: interpolate(\n            value,\n            inputRange,\n            curves.map((c) => c.c1.y)\n          ),\n        },\n        c2: {\n          x: interpolate(\n            value,\n            inputRange,\n            curves.map((c) => c.c2.x)\n          ),\n          y: interpolate(\n            value,\n            inputRange,\n            curves.map((c) => c.c2.y)\n          ),\n        },\n      } as Curve;\n    }\n    return segment;\n  });\n  return serialize(path);\n};\n\nexport const mixPath = (value: number, p1: Path, p2: Path) => {\n  \"worklet\";\n  return interpolatePath(value, [0, 1], [p1, p2]);\n};\n\nexport const move = (x: number, y: number) => {\n  \"worklet\";\n  return { type: SVGCommand.MOVE as const, x, y };\n};\n\nexport const curve = (c: Omit<Curve, \"type\">) => {\n  \"worklet\";\n  return {\n    type: SVGCommand.CURVE as const,\n    c1: c.c1,\n    c2: c.c2,\n    to: c.to,\n    from: c.from,\n  };\n};\n\nexport const close = () => {\n  \"worklet\";\n  return { type: SVGCommand.CLOSE as const };\n};\n\nexport const getYForX = (path: Path, x: number) => {\n  \"worklet\";\n  const p = path.filter((c) => {\n    if (isCurve(c)) {\n      if (c.from.x > c.to.x) {\n        return x >= c.to.x && x <= c.from.x;\n      }\n      return x >= c.from.x && x <= c.to.x;\n    }\n    return false;\n  });\n  if (isCurve(p[0])) {\n    return cubicBezierYForX(x, p[0].from, p[0].c1, p[0].c2, p[0].to);\n  }\n  return 0;\n};\n"]},"metadata":{},"sourceType":"module"}