{"version":3,"sources":["Paths.ts"],"names":["interpolate","parseSVG","absSVG","normalizeSVG","cubicBezierYForX","SVGCommand","exhaustiveCheck","command","TypeError","serializeMove","c","x","y","serializeClose","serializeCurve","c1","c2","to","isMove","type","MOVE","isCurve","CURVE","isClose","CLOSE","serialize","path","map","segment","reduce","acc","parse","d","segments","index","move","close","prev","r","curve","from","interpolatePath","value","inputRange","outputRange","points","p","s","Error","curves","mixPath","p1","p2","getYForX","filter"],"mappings":"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","sourcesContent":["import { interpolate } from \"react-native-reanimated\";\nimport parseSVG from \"parse-svg-path\";\nimport absSVG from \"abs-svg-path\";\nimport normalizeSVG from \"normalize-svg-path\";\n\nimport { Vector } from \"./Vectors\";\nimport { cubicBezierYForX } from \"./Math\";\n\ntype SVGCloseCommand = [\"Z\"];\ntype SVGMoveCommand = [\"M\", number, number];\ntype SVGCurveCommand = [\"C\", number, number, number, number, number, number];\ntype SVGNormalizedCommands = [\n  SVGMoveCommand | SVGCurveCommand | SVGCloseCommand\n];\n\nexport enum SVGCommand {\n  MOVE,\n  CURVE,\n  CLOSE,\n}\n\ninterface Move extends Vector {\n  type: SVGCommand.MOVE;\n}\n\ninterface Curve {\n  type: SVGCommand.CURVE;\n  from: Vector;\n  to: Vector;\n  c1: Vector;\n  c2: Vector;\n}\n\ninterface Close {\n  type: SVGCommand.CLOSE;\n}\n\nexport type Segment = Close | Curve | Move;\nexport type Path = Segment[];\n\nexport const exhaustiveCheck = (command: never): never => {\n  \"worklet\";\n  throw new TypeError(`Unknown SVG Command: ${command}`);\n};\n\nconst serializeMove = (c: Move) => {\n  \"worklet\";\n  return `M${c.x},${c.y} `;\n};\n\nconst serializeClose = () => {\n  \"worklet\";\n  return \"Z\";\n};\n\nconst serializeCurve = (c: Curve) => {\n  \"worklet\";\n  return `C${c.c1.x},${c.c1.y} ${c.c2.x},${c.c2.y} ${c.to.x},${c.to.y} `;\n};\n\nconst isMove = (command: Segment): command is Move => {\n  \"worklet\";\n  return command.type === SVGCommand.MOVE;\n};\n\nconst isCurve = (command: Segment): command is Curve => {\n  \"worklet\";\n  return command.type === SVGCommand.CURVE;\n};\n\nconst isClose = (command: Segment): command is Close => {\n  \"worklet\";\n  return command.type === SVGCommand.CLOSE;\n};\n\nexport const serialize = (path: Path) => {\n  \"worklet\";\n  return path\n    .map((segment) => {\n      if (isMove(segment)) {\n        return serializeMove(segment);\n      }\n      if (isCurve(segment)) {\n        return serializeCurve(segment);\n      }\n      if (isClose(segment)) {\n        return serializeClose();\n      }\n      return exhaustiveCheck(segment);\n    })\n    .reduce((acc, c) => acc + c);\n};\n\nexport const parse = (d: string): Path => {\n  const segments: SVGNormalizedCommands = normalizeSVG(absSVG(parseSVG(d)));\n  return segments.map((segment, index) => {\n    if (segment[0] === \"M\") {\n      return move(segment[1], segment[2]);\n    } else if (segment[0] === \"Z\") {\n      return close();\n    } else {\n      const prev = segments[index - 1];\n      const r = curve({\n        c1: {\n          x: segment[1],\n          y: segment[2],\n        },\n        c2: {\n          x: segment[3],\n          y: segment[4],\n        },\n        to: {\n          x: segment[5],\n          y: segment[6],\n        },\n        from: {\n          x: (prev[0] === \"M\" ? prev[1] : prev[5]) ?? 0,\n          y: (prev[0] === \"M\" ? prev[2] : prev[6]) ?? 0,\n        },\n      });\n      return r;\n    }\n  });\n};\n\nexport const interpolatePath = (\n  value: number,\n  inputRange: number[],\n  outputRange: Path[]\n) => {\n  \"worklet\";\n  const path = outputRange[0].map((segment, index) => {\n    if (isMove(segment)) {\n      const points = outputRange.map((p) => {\n        const s = p[index];\n        if (isMove(s)) {\n          return {\n            x: s.x,\n            y: s.y,\n          };\n        }\n        throw new Error(\"Paths to interpolate are not symetrical\");\n      });\n      return {\n        type: SVGCommand.MOVE,\n        x: interpolate(\n          value,\n          inputRange,\n          points.map((p) => p.x)\n        ),\n        y: interpolate(\n          value,\n          inputRange,\n          points.map((p) => p.y)\n        ),\n      } as Move;\n    }\n    if (isCurve(segment)) {\n      const curves = outputRange.map((p) => {\n        const s = p[index];\n        if (isCurve(s)) {\n          return {\n            to: s.to,\n            c1: s.c1,\n            c2: s.c2,\n          };\n        }\n        throw new Error(\"Paths to interpolate are not symetrical\");\n      });\n      return {\n        type: SVGCommand.CURVE,\n        to: {\n          x: interpolate(\n            value,\n            inputRange,\n            curves.map((c) => c.to.x)\n          ),\n          y: interpolate(\n            value,\n            inputRange,\n            curves.map((c) => c.to.y)\n          ),\n        },\n        c1: {\n          x: interpolate(\n            value,\n            inputRange,\n            curves.map((c) => c.c1.x)\n          ),\n          y: interpolate(\n            value,\n            inputRange,\n            curves.map((c) => c.c1.y)\n          ),\n        },\n        c2: {\n          x: interpolate(\n            value,\n            inputRange,\n            curves.map((c) => c.c2.x)\n          ),\n          y: interpolate(\n            value,\n            inputRange,\n            curves.map((c) => c.c2.y)\n          ),\n        },\n      } as Curve;\n    }\n    return segment;\n  });\n  return serialize(path);\n};\n\nexport const mixPath = (value: number, p1: Path, p2: Path) => {\n  \"worklet\";\n  return interpolatePath(value, [0, 1], [p1, p2]);\n};\n\nexport const move = (x: number, y: number) => {\n  \"worklet\";\n  return { type: SVGCommand.MOVE as const, x, y };\n};\n\nexport const curve = (c: Omit<Curve, \"type\">) => {\n  \"worklet\";\n  return {\n    type: SVGCommand.CURVE as const,\n    c1: c.c1,\n    c2: c.c2,\n    to: c.to,\n    from: c.from,\n  };\n};\n\nexport const close = () => {\n  \"worklet\";\n  return { type: SVGCommand.CLOSE as const };\n};\n\nexport const getYForX = (path: Path, x: number) => {\n  \"worklet\";\n  const p = path.filter((c) => {\n    if (isCurve(c)) {\n      if (c.from.x > c.to.x) {\n        return x >= c.to.x && x <= c.from.x;\n      }\n      return x >= c.from.x && x <= c.to.x;\n    }\n    return false;\n  });\n  if (isCurve(p[0])) {\n    return cubicBezierYForX(x, p[0].from, p[0].c1, p[0].c2, p[0].to);\n  }\n  return 0;\n};\n"]}